
- LoopContext should be totally invisible.
  - ReaDIEngine.AddObject (and Run methods) should be the only
     exposed API.
==> Done.

- Loop types are discovered by the ReaDIParameter ([ReaDILoop] or ReadyLoop<T,TState>).
- A "loop type" cannot be variant. 2 loop types must be unrelated.
  - If loop types can be interfaces or non sealed classes then 2 loop ReaDIParameters 
    can be satisfied by the same object.
    This must not happen. We can (only) check this at runtime (when adding object).
- A LoopContext exist because there are handlers where methods have one or more loop ReaDIParameter.
  A LoopContext is "defined" by the existence of such methods.
- Parameter order matters when dealing with loops. From left to right, loop parameters order 
  defines the parent/child relationships.
  - Loops can be loosely defined:
	void M1( [ReaDILoop]A )
	void M2( [ReaDILoop]B )
    Here we don't know the order until A or B is added.
  - A new handler with a void M3( ..., [ReaDILoop]A, ..., [ReaDILoop]B, ... ) defines the ordering.
    A "LoopPath" is created. Any conflict with an existing LoopPath is an error.
    A "LoopTree" is maintained dynamically. Methods are attached to their most precise loop parameter 
    and are "sleeping" (deactivated) until all their loop params are satisified.
	Here we have:
		A - M1
		  B - M2, M3  
    When a new M4( [ReaDILoop]C ) pops:    
		A - M1
		  B - M2, M3
		C - M4
    1 - Object A appears.
        LoopContext for A is created.
        M1 is executed.
        We have no B: M2 and M3 cannot be executed. 
	The LoopContext is closed.
    2 - Object B appears. It's an error: the path A - B exists.
    3 - Object A appears. M1 is executed.
        If M1 returns a B, then M2 and M3 are executed.

  - Methods that have loop parameters are "sleeping" (deactivated) until all their loop params are satisified.
  - If an order has been detected, all the parameters of the "order" (a LoopPath ?) must be satisfied.
==> This doesn't work. We cannot infer the "LoopTree" from the parameters without introducing
    ambiguities in the path. Loop parameters must be defined as such.
    [ReaDILoopRootParameter] and [ReaDILoopParameter<TParent>] has been introduced.

  - How do we know that a loop is over?
    - When A is added, a LoopContext is created.
    - All the methods that have A. 
      This context inherits the current objects of its parent context.
      Should the current handlers/methods still be active?
	- The current handlers of its parent context.
    => Not clear. Should a "loop context" contains "local objects"?

  - Better (first) question: How do we know that the Engine is done?
    - There is no more Callable waiting for any of their arguments.
    - As simple as that IF we don't reset the LoopParameterType's CurrentValue once the loop is over.
      But it seems that we need to reset otherwise we need a state that knows that... This state may well be
      required to handle the loop anyway.
  ==> The ReaDIEngineState captures this.

- Object pops at runtime, objects can be handlers. A handler can be consumed by methods
  on another handler.

- At runtime, adding an object that specializes an existing (added) object 
   should not be allowed.
   -  If yes it means that a ReaDIParameter can be bound to a 
      generalization and the specialization will be ignored. But new 
      handlers will use it instead of the generalization.
   - It seems that ReaDIParameters defines families.
     Considering that the formal parameters are unrelated may seem a strong constraint
     but the more I think to this the more it seems obvious: with this rule, the contravariance
     (at runtime) can be efficiently implemented:
     - In AddObject if oT is not found, it searches the generalizations: (Generalizations are Interfaces + BaseTypes
       as we only handle classes and interfaces).
     - When creating a new ParameterType, we check that it is independent from all the existing ParameterTypes:
       this means thet their current values have no chance to satisfy the new ParameterType, that any future added object
       won't satisfy 2 Parameter types and that any waiting object can be assigned to at most one future ParameterType.
       The waiting objects can then be used by trying them in the same way (oT + BaseType + Interfaces) and if a waiting object
       satisfies the ParameterType, it is removed from the waiting list.
       If no matching waiting object is found, then Handlers should be tried: they are available objects that
       can perfectly satisfy a method's parameter of another handler.
       This guaranties the soundess of the system... But:

Static type checking is limited. If 2 parameters MUST not be satisfied by the same instance.
The static type check is that they must have no common generalization at all.
This check is VERY strong: this prevents any template method pattern or unrelated useful interface
in parameters (even our own IReaDIHandler would be forbidden).
One may think that they must have no ""instantiable"" common generalization
is right but unfortunately, "instantiable" cannot be computed for an interface and even an abstract
class may eventually be implemented by code.

Introducing a [CKAbstract] marker (the current [CKTypeDefiner]) can solve the issue. A ParameterType cannot
be a [CKAbstract] type and [CKAbstract] types are excluded from the Generalizations (BaseTypes + Interfaces).
But even with this we must check the unicity at runtime: considering only the first matching parameter will introduce
a possible random (order dependent) behavior. This is costly: once a matching has been found (from an ParameterType on a new object
or from a waiting object or a Handler on a new ParameterType), the lookup must continue and be executed for ALL the candidates until
a second match is found (and an error is raised). An index may be built and maintained...

I've just introduced a DebugMode on the ReaDIEngine: this can be used to trigger this "deep check"...

What if we don't support contravariance?
It would mean that we must stick to concrete classes on both side of the system: one would not be able
to have a consumer like `void DoSomething( IThing t )` with a producer that instantiate the different concrete thing
(based on configuration or any other state of the system).
This is unbearable.

What if we support contravariance only for abstract classes (not interfaces)?
This will allow a consumer like `void DoSomething( ThingBase t )` with a producer that instantiate the concrete thing.
This is the only approach without the CKomposable [Abstract] attribute. Forbidding interfaces is too surprising and
too limited.
==> ICachedType.IsTypeDefiner and ICachedType.IsSuperTypeDefiner are implemented. They use CKTypeDefiner and CKSuperTypeDefiner.
    We should decide the definitive naming asap. 


While trying to handle the root loop: [AlsoRegisterType] is an issue.
From an initial set of type, we consider all the EngineAttribute that are IReaDIHandler but any
[AlsoRegisterType] must extend the set (recursively).
Any previously added IReaDIHandler must not be "active" when the set changes (different BinPath).
This is like a "super loop" because the handlers themselves are impacted.
Tried a [HierarchicalTypeRoot] public sealed class PreRunningGroup that would allow registering new types
(and handles the EngineAttribute that are IReaDIHandler on new types) BUT this will not handle
optional packages (in TypeScript). TypeScriptPackages (from the initial TypeSet) must be able to
interact with the ResSpaceConfiguration & ResSpaceCollector (to register the package in the ResSpace)
but if the package is optional, it must NOT interact with the ResSpaceData anymore (it must not interact
whith anything). The solution seems to support the "Type Set" notion at the ReaDIEngine level.
Following the current bet that HandlerType and ParameterType can hold their "CurrentValue" (this has yet
to be proved), Activating/Deactivating a Type from the "AvailableTypes" (or the "TypeWorkingSet"... this
originally is the BinPathTypeGroup "AllTypes" set but AllTypes will be ambiguous - this is not the engine
types but types that can have IReaDIHandler though their EngineAttributes...).

"SourceTypeSet" may be better.

A Dictionary<ICachedType,HandlerType?> should be wrapped in a IReadOnlySet<ICachedType> and the HandlerType
must have a HandlerType? _nextSourceType (single linked list).
It must also have a bool _inactive (that defaults to false and that Callables should check before pushing themselves).
When _inactive is true, a satisfied callable should not push and enter a new final state ("Skipped"?).
When a SourceType is added to the SourceTypeSet, it should reactivate its handlers if it was already known.
This Dictionary, once again, is in append only. This new SourceTypeSet doesn't change anything else in the current
code base. It integrates the Type => EngineAttribute : IReaDIHandler association.

Note: an optional package SHOULD NOT have a [AlsoRegisterType]. TODO: implement this check.

Member's EngineAttribute should also be registered here and be also bound to the source type. To avoid
a systematic lookup on the members and following the "primary attribute philosophy", we'll introduce
a guard: members will be handled only if at least one type engine attribute has been found.






