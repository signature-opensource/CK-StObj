using CK.Core;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using static CK.Testing.StObjEngineTestHelper;

namespace CK.StObj.Engine.Tests.Endpoint.Conformant
{
    sealed class FakeEndpointDefinition : EndpointDefinition<FakeEndpointDefinition.Data>
    {
        public sealed class Data
        {
        }

        public override string Name => "Fake";

        public override IReadOnlyList<Type> ScopedServices => Type.EmptyTypes;

        public override IReadOnlyList<Type> SingletonServices => Type.EmptyTypes;

        // This method is implemented by the developer of the Endpoint.
        public override void ConfigureEndpointServices( IServiceCollection services, IServiceProviderIsService globalServiceExists )
        {
        }

        sealed class FakeStObjMap : IStObjMap
        {
            public IStObjObjectMap StObjs => throw new NotImplementedException();

            public SHA1Value GeneratedSignature => throw new NotImplementedException();

            public IStObjServiceMap Services => throw new NotImplementedException();

            public IReadOnlyList<string> Names => throw new NotImplementedException();

            public IReadOnlyCollection<VFeature> Features => throw new NotImplementedException();

            public IStObjFinalClass? ToLeaf( Type t ) => null;

            // This method is generated by code.
            // Note: When no EndpointDefinition exist, the code that manages endpoints is not generated.
            public bool ConfigureServices( in StObjContextRoot.ServiceRegister reg )
            {
                // Gives the real objects an opportunity to configure the services.
                RealObjectConfigureServices( in reg );

                //  - We build the blueprint of ServiceDescriptors from the globalConfiguration
                //    These registrations are:
                //      - a relay to the global container for singletons.
                //      - the same descriptor for scoped services.
                //    This fills the ServiceType => Mapping externalMappings.
                var externalMappings = new Dictionary<Type, Mapping>();
                var common = EndpointHelper.CreateCommonEndpointContainer( reg.Monitor, reg.Services, EndpointTypeManager_CK._endpointServices.Contains, externalMappings );

                // - We add the code generated HostedServiceLifetimeTrigger to the global container: the endpoint
                //   containers don't need it.
                //   We don't do it here to avoid creating yet another fake implementation.
                //   
                // reg.Services.Add( new Microsoft.Extensions.DependencyInjection.ServiceDescriptor( typeof( IHostedService ), typeof( HostedServiceLifetimeTrigger ), ServiceLifetime.Singleton ) );
                //

                //  - Then an instance of the special "super singleton" EndpointTypeManager is created.
                //    It is the exact same instance that will be available from all the containers: the global and every endpoint containers, it is
                //    the global hook, the relay to the global service provider for the endpoint containers.
                var theEPTM = new EndpointTypeManager_CK();
                var descEPTM = new ServiceDescriptor( typeof( EndpointTypeManager ), theEPTM );
                reg.Services.Add( descEPTM );
                common.Add( descEPTM );
                FillUniqueMappingsAndGlobalMultipleMappings( reg.Monitor, reg.Services, common );
                FillMultipleEndpointMappingsFromStObj( reg.Monitor, externalMappings );
                // We can now close the global container. Waiting for .Net 8.
                // (reg.Services as Microsoft.Extensions.DependencyInjection.ServiceCollection)?.MakeReadOnly();
                bool success = true;
                //  - Then all the endpointType instances create their own ServiceCollection by copying the blueprint
                //    descriptors and adding their own EndpointScopeData<TScopeData> scoped data holder. 
                foreach( var e in theEPTM._endpointTypes )
                {
                    if( !e.ConfigureServices( reg.Monitor, this, common, externalMappings ) ) success = false;
                }
                return success;
            }

            // This is a code generated method that calls all static RegisterStartupServices methods and then
            // all static ConfigureServices methods (following the topological dependency order).
            void RealObjectConfigureServices( in StObjContextRoot.ServiceRegister register )
            {
            }

            // This is a code generated method.
            // For real objects, the global and the endpoint blueprint are filled with the
            // same ServiceDesctiptors objects that reference the "true" real objects instances.
            // There is no intermediate list or array: the global and the common configuration (if one is
            // needed) are directly configured.
            // For auto services, it a little bit more complicated:
            //  - For a Scoped type:
            //      - Its ClassType is mapped to the FinalType for both Global end Endpoint containers.
            //      - Its unique mappings are mapped to sp => sp.GetService( m.ClassType ) for both Global end Endpoint containers.
            //  - For a Singleton type:
            //      - The ClassType is mapped to the FinalType for the Global container.
            //      - For the Endpoint container, the ClassType is mapped to a relay to the GlobalServiceProvider's registration ClassType.
            //      - Its unique mappings are:
            //          - Mapped to sp => sp.GetService( m.ClassType ) for the Global container.
            //          - Mapped to a relay to the GlobalServiceProvider's registration ClassType.
            //
            // Multiple mappings are registered only in the global container by this method. Endpoint container configuration of multiple
            // registrations is done by FillMultipleEndpointMappings().
            //
            void FillUniqueMappingsAndGlobalMultipleMappings( IActivityMonitor monitor, IServiceCollection global, IServiceCollection? commonEndpoint )
            {
            }

            // This is a code generated method.
            // Multiple StObj mappings are injected into the externalMappings: the injected ServiceDescriptors are
            // only in this dictionary to allow the ExternalMultipleHelper to include the real objects and auto services
            // in its work.
            void FillMultipleEndpointMappingsFromStObj( IActivityMonitor monitor, Dictionary<Type, Mapping> externalMappings )
            {
            }


        }

        // The EndpointTypeManager is code generated.
        sealed class EndpointTypeManager_CK : EndpointTypeManager
        {
            // EndpointDefinition are IRealObject: they are static and resolved from
            // the GeneratedRootContext.GenStObj.
            // Here we fake it with a null default and our FakeEndpointDefinition.
            static readonly DefaultEndpointDefinition _default;
            static readonly EndpointDefinition[] _endpoints;
            internal static HashSet<Type> _endpointServices;
            internal readonly IEndpointTypeInternal[] _endpointTypes;

            static EndpointTypeManager_CK()
            {
                _default = null!;
                _endpointServices = new HashSet<Type>();
                _endpoints = new EndpointDefinition[] { _default, new FakeEndpointDefinition() };    
            }

            // The instance constructor initializes the endpoint type from the definitions.
            // (There is no EndpointType for the DefaultEndpointDefinition.)
            public EndpointTypeManager_CK()
            {
                _endpointTypes = new IEndpointTypeInternal[]
                {
                    new EndpointType<FakeEndpointDefinition.Data>( new FakeEndpointDefinition() )
                };
            }

            public override DefaultEndpointDefinition DefaultEndpointDefinition => _default;

            public override IReadOnlyList<EndpointDefinition> AllEndpointDefinitions => _endpoints;

            public override IReadOnlySet<Type> EndpointServices => _endpointServices;

            public override IReadOnlyList<IEndpointType> EndpointTypes => _endpointTypes;

            // This is called by the code generated HostedServiceLifetimeTrigger constructor. 
            internal void SetGlobalContainer( IServiceProvider serviceProvider ) => _global = serviceProvider;
        }

        public static EndpointServiceProvider<FakeEndpointDefinition.Data>? CreateServiceProvider( IActivityMonitor monitor,
                                                                                                   IServiceCollection globalConfiguration,
                                                                                                   out IServiceProvider? globalServiceProvider )
        {
            FakeStObjMap stObjMap = new FakeStObjMap();
            var reg = new StObjContextRoot.ServiceRegister( monitor, globalConfiguration );
            // 1 - This is the AddStObjMap work.
            if( !stObjMap.ConfigureServices( reg ) )
            {
                globalServiceProvider = null;
                return null;
            }
            // 2 - Once the global DI container is built, the code generated HostedServiceLifetimeTrigger sets the global
            //     container on THE EndpointTypeManager from its constructor: the HostedServiceLifetimeTrigger
            //     is a regular IHostedService, ISingletonAutoService that takes the global IServiceProvider in its constructor.

            // This is done by the application host.
            globalServiceProvider = globalConfiguration.BuildServiceProvider();

            // HostedServiceLifetimeTrigger constructor.
            var theEPTM = ((EndpointTypeManager_CK)globalServiceProvider.GetRequiredService<EndpointTypeManager>());
            theEPTM.SetGlobalContainer( globalServiceProvider );

            // 3 - From now on, on demand (this is lazily initialized), the endpoints are able to expose their
            //     own DI container.
            var endpointType = globalServiceProvider.GetRequiredService<EndpointTypeManager>()
                                .EndpointTypes
                                .OfType<EndpointType<FakeEndpointDefinition.Data>>()
                                .Single();
            return endpointType.GetContainer();
        }

    }
}
