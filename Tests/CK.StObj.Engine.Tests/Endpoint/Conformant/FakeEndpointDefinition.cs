using CK.Core;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using static CK.Testing.StObjEngineTestHelper;

namespace CK.StObj.Engine.Tests.Endpoint.Conformant
{
    sealed class FakeEndpointDefinition : EndpointDefinition<FakeEndpointDefinition.Data>
    {
        public sealed class Data
        {
        }

        public override string Name => "Fake";

        public override IReadOnlyList<Type> ScopedServices => Type.EmptyTypes;

        public override IReadOnlyList<Type> SingletonServices => Type.EmptyTypes;

        // This method is implemented by the developer of the Endpoint.
        public override void ConfigureEndpointServices( IServiceCollection services )
        {
        }

        sealed class FakeStObjMap : IStObjMap
        {
            public IStObjObjectMap StObjs => throw new NotImplementedException();

            public SHA1Value GeneratedSignature => throw new NotImplementedException();

            public IStObjServiceMap Services => throw new NotImplementedException();

            public IReadOnlyList<string> Names => throw new NotImplementedException();

            public IReadOnlyCollection<VFeature> Features => throw new NotImplementedException();

            public IStObjFinalClass? ToLeaf( Type t ) => null;

            // This method is generated by code. 
            public bool ConfigureEndpointServices( in StObjContextRoot.ServiceRegister reg )
            {
                //  - First we build the blueprint of ServiceDescriptors from the globalConfiguration
                //
                //    TODO: only with the services configured by the application host. Currently the real objects and
                //          the auto services are already added. This will be more efficient to process the real objects and
                //          the auto services explicitly (and safer for the IEnumerable<> support).
                //          This "ConfigureEndpointServices" will be "ConfigureServices".
                //          
                var common = EndpointHelper.CreateCommonEndpointContainer( reg.Monitor, reg.Services, EndpointTypeManager_CK._endpointServices.Contains );

                // - We add the code generated HostedServiceLifetimeTrigger to the global container: the endpoint
                //   containers don't need it. We don't do it here to avoid creating yet another fake implementation.
                //   
                // reg.Services.Add( new Microsoft.Extensions.DependencyInjection.ServiceDescriptor( typeof( IHostedService ), typeof( HostedServiceLifetimeTrigger ), ServiceLifetime.Singleton ) );
                //

                //  - Then an instance of the special "super singleton" EndpointTypeManager is created.
                //    It is the exact same instance that will be available from all the containers: the global and every endpoint containers.
                var theEPTM = new EndpointTypeManager_CK();
                var descEPTM = new ServiceDescriptor( typeof( EndpointTypeManager ), theEPTM );
                reg.Services.Add( descEPTM );
                common.Add( descEPTM );
                FillRealObjectMappings( reg.Monitor, reg.Services, common );
                // We can now close the global container. Waiting for .Net 8.
                // (reg.Services as Microsoft.Extensions.DependencyInjection.ServiceCollection)?.MakeReadOnly();
                bool success = true;
                //  - Then all the endpointType instances create their own ServiceCollection by copying the blueprint
                //    descriptors and adding their own EndpointScopeData<TScopeData> scoped data holder. 
                foreach( var e in theEPTM._endpointTypes )
                {
                    if( !e.ConfigureServices( reg.Monitor, this, common ) ) success = false;
                }
                return success;
            }

            // This is code generated method. The global and the endpoint blueprint are filled
            // with the same ServiceDesctiptors objects that reference the "true" real objects instances.
            // There is no intermediate list or array: the global and the common configuration (if one is
            // needed) are directly configured.
            void FillRealObjectMappings( IActivityMonitor monitor, IServiceCollection global, IServiceCollection? commonEndpoint )
            {
            }
        }

        // The EndpointTypeManager is code generated.
        sealed class EndpointTypeManager_CK : EndpointTypeManager
        {
            // EndpointDefinition are IRealObject: they are static and resolved from
            // the GeneratedRootContext.GenStObj.
            // Here we fake it with a null default and our FakeEndpointDefinition.
            static readonly DefaultEndpointDefinition _default;
            static readonly EndpointDefinition[] _endpoints;
            internal static HashSet<Type> _endpointServices;
            internal readonly IEndpointTypeInternal[] _endpointTypes;

            static EndpointTypeManager_CK()
            {
                _default = null!;
                _endpointServices = new HashSet<Type>();
                _endpoints = new EndpointDefinition[] { _default, new FakeEndpointDefinition() };    
            }

            // The instance constructor initializes the endpoint type from the definitions.
            // (There is no EndpointType for the DefaultEndpointDefinition.)
            public EndpointTypeManager_CK()
            {
                _endpointTypes = new IEndpointTypeInternal[]
                {
                    new EndpointType<FakeEndpointDefinition.Data>( new FakeEndpointDefinition() )
                };
            }

            public override DefaultEndpointDefinition DefaultEndpointDefinition => _default;

            public override IReadOnlyList<EndpointDefinition> AllEndpointDefinitions => _endpoints;

            public override IReadOnlySet<Type> EndpointServices => _endpointServices;

            public override IReadOnlyList<IEndpointType> EndpointTypes => _endpointTypes;

            // This is called by the code generated HostedServiceLifetimeTrigger constructor. 
            internal void SetGlobalContainer( IServiceProvider serviceProvider ) => _global = serviceProvider;
        }

        public static EndpointServiceProvider<FakeEndpointDefinition.Data>? CreateServiceProvider( IActivityMonitor monitor,
                                                                                                   IServiceCollection globalConfiguration,
                                                                                                   out IServiceProvider? globalServiceProvider )
        {
            FakeStObjMap stObjMap = new FakeStObjMap();
            var reg = new StObjContextRoot.ServiceRegister( monitor, globalConfiguration );
            // 1 - This is the AddStObjMap work.
            if( !stObjMap.ConfigureEndpointServices( reg ) )
            {
                globalServiceProvider = null;
                return null;
            }
            // 2 - Once the global DI container is built, the code generated HostedServiceLifetimeTrigger sets the global
            //     container on THE EndpointTypeManager from its constructor: the HostedServiceLifetimeTrigger
            //     is a regular IHostedService, ISingletonAutoService that takes the global IServiceProvider in its constructor.

            // This is done by the application host.
            globalServiceProvider = globalConfiguration.BuildServiceProvider();

            // HostedServiceLifetimeTrigger constructor.
            var theEPTM = (EndpointTypeManager_CK)globalServiceProvider.GetRequiredService<EndpointTypeManager>();
            theEPTM.SetGlobalContainer( globalServiceProvider );

            // 3 - From now on, on demand (this is lazily initialized), the endpoints are able to expose their
            //     own DI container.
            var endpointType = globalServiceProvider.GetRequiredService<EndpointTypeManager>()
                                .EndpointTypes
                                .OfType<EndpointType<FakeEndpointDefinition.Data>>()
                                .Single();
            return endpointType.GetContainer();
        }

    }
}
