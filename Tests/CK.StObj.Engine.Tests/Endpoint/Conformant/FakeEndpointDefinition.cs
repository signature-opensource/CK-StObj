using CK.Core;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using static CK.Testing.StObjEngineTestHelper;

namespace CK.StObj.Engine.Tests.Endpoint.Conformant
{
    sealed class FakeEndpointDefinition : EndpointDefinition<FakeEndpointDefinition.Data>
    {
        public sealed class Data
        {
        }

        public override string Name => "Fake";

        public override IReadOnlyList<Type> ScopedServices => Type.EmptyTypes;

        public override IReadOnlyList<Type> SingletonServices => Type.EmptyTypes;

        // This method is implemented by the developer of the Endpoint.
        public override void ConfigureEndpointServices( IServiceCollection services, IServiceProviderIsService globalServiceExists )
        {
        }

        sealed class FakeStObjMap : IStObjMap
        {
            public IStObjObjectMap StObjs => throw new NotImplementedException();

            public SHA1Value GeneratedSignature => throw new NotImplementedException();

            public IStObjServiceMap Services => throw new NotImplementedException();

            public IReadOnlyList<string> Names => throw new NotImplementedException();

            public IReadOnlyCollection<VFeature> Features => throw new NotImplementedException();

            public IReadOnlyDictionary<Type, IStObjMultipleInterface> MultipleMappings => throw new NotImplementedException();

            public IStObjFinalClass? ToLeaf( Type t ) => null;

            // This method is generated by code.
            // Note: When no EndpointDefinition exist, the code that manages endpoints is not generated.
            public bool ConfigureServices( in StObjContextRoot.ServiceRegister reg )
            {
                // Gives the real objects an opportunity to configure the services.
                RealObjectConfigureServices( in reg );

                //  We must build a mapping of ServiceType -> ServiceDescriptors from the global configuration.
                var mappings = EndpointHelper.CreateInitialMapping( reg.Monitor, reg.Services, EndpointTypeManager_CK._endpointServices.Contains );

                // - We add the code generated HostedServiceLifetimeTrigger to the global container: the endpoint
                //   containers don't need it.
                //   We don't do it here to avoid creating yet another fake implementation.
                //   
                // reg.Services.Add( new Microsoft.Extensions.DependencyInjection.ServiceDescriptor( typeof( IHostedService ), typeof( HostedServiceLifetimeTrigger ), ServiceLifetime.Singleton ) );
                //

                //  - Then an instance of the special "super singleton" EndpointTypeManager is created.
                //    It is the exact same instance that will be available from all the containers: the global and every endpoint containers, it is
                //    the global hook, the relay to the global service provider for the endpoint containers.
                var theEPTM = new EndpointTypeManager_CK();
                var descEPTM = new ServiceDescriptor( typeof( EndpointTypeManager ), theEPTM );
                reg.Services.Add( descEPTM );

                // This is code generated.
                // ServiceDescriptors are created from the EngineStObjMap and added to the global configuration
                // and to the mappings.
                FillStObjMappings( reg.Monitor, reg.Services, mappings );

                // We can now close the global container. Waiting for .Net 8.
                // (reg.Services as Microsoft.Extensions.DependencyInjection.ServiceCollection)?.MakeReadOnly();
                bool success = true;
                //  - Then all the endpointType instances create their own ServiceCollection by processing the 
                //    descriptors from the mappings and adding their own EndpointScopeData<TScopeData> scoped data holder
                //    and the true instance singletons IStObjMap and EndpointTypeManager. 
                foreach( var e in theEPTM._endpointTypes )
                {
                    if( !e.ConfigureServices( reg.Monitor, this, mappings, descEPTM ) ) success = false;
                }
                return success;
            }

            // This is a code generated method that calls all static RegisterStartupServices methods and then
            // all static ConfigureServices methods (following the topological dependency order).
            void RealObjectConfigureServices( in StObjContextRoot.ServiceRegister register )
            {
            }

            // This is a code generated method.
            // If there is at least one endpoint, mappings is not null and we upsert the Mapping objects
            // with the service descriptors that are added to the global service collection.
            void FillStObjMappings( IActivityMonitor monitor, IServiceCollection global, Dictionary<Type, Mapping>? mappings )
            {
            }

            // This is a code generated method.
            // Multiple StObj mappings are injected into the externalMappings: the injected ServiceDescriptors are
            // only in this dictionary to allow the ExternalMultipleHelper to include the real objects and auto services
            // in its work.
            void FillMultipleEndpointMappingsFromStObj( IActivityMonitor monitor, Dictionary<Type, Mapping> externalMappings )
            {
            }


        }

        // The EndpointTypeManager is code generated.
        sealed class EndpointTypeManager_CK : EndpointTypeManager
        {
            // EndpointDefinition are IRealObject: they are static and resolved from
            // the GeneratedRootContext.GenStObj.
            // Here we fake it with a null default and our FakeEndpointDefinition.
            static readonly DefaultEndpointDefinition _default;
            static readonly EndpointDefinition[] _endpoints;
            internal static HashSet<Type> _endpointServices;
            internal readonly IEndpointTypeInternal[] _endpointTypes;

            static EndpointTypeManager_CK()
            {
                _default = null!;
                _endpointServices = new HashSet<Type>();
                _endpoints = new EndpointDefinition[] { _default, new FakeEndpointDefinition() };    
            }

            // The instance constructor initializes the endpoint type from the definitions.
            // (There is no EndpointType for the DefaultEndpointDefinition.)
            public EndpointTypeManager_CK()
            {
                _endpointTypes = new IEndpointTypeInternal[]
                {
                    new EndpointType<FakeEndpointDefinition.Data>( new FakeEndpointDefinition() )
                };
            }

            public override DefaultEndpointDefinition DefaultEndpointDefinition => _default;

            public override IReadOnlyList<EndpointDefinition> AllEndpointDefinitions => _endpoints;

            public override IReadOnlySet<Type> EndpointServices => _endpointServices;

            public override IReadOnlyList<IEndpointType> EndpointTypes => _endpointTypes;

            // This is called by the code generated HostedServiceLifetimeTrigger constructor. 
            internal void SetGlobalContainer( IServiceProvider serviceProvider ) => _global = serviceProvider;
        }

        public static EndpointServiceProvider<FakeEndpointDefinition.Data>? CreateServiceProvider( IActivityMonitor monitor,
                                                                                                   IServiceCollection globalConfiguration,
                                                                                                   out IServiceProvider? globalServiceProvider )
        {
            FakeStObjMap stObjMap = new FakeStObjMap();
            var reg = new StObjContextRoot.ServiceRegister( monitor, globalConfiguration );
            // 1 - This is the AddStObjMap work.
            if( !stObjMap.ConfigureServices( reg ) )
            {
                globalServiceProvider = null;
                return null;
            }
            // 2 - Once the global DI container is built, the code generated HostedServiceLifetimeTrigger sets the global
            //     container on THE EndpointTypeManager from its constructor: the HostedServiceLifetimeTrigger
            //     is a regular IHostedService, ISingletonAutoService that takes the global IServiceProvider in its constructor.

            // This is done by the application host.
            globalServiceProvider = globalConfiguration.BuildServiceProvider();

            // HostedServiceLifetimeTrigger constructor.
            var theEPTM = ((EndpointTypeManager_CK)globalServiceProvider.GetRequiredService<EndpointTypeManager>());
            theEPTM.SetGlobalContainer( globalServiceProvider );

            // 3 - From now on, on demand (this is lazily initialized), the endpoints are able to expose their
            //     own DI container.
            var endpointType = globalServiceProvider.GetRequiredService<EndpointTypeManager>()
                                .EndpointTypes
                                .OfType<EndpointType<FakeEndpointDefinition.Data>>()
                                .Single();
            return endpointType.GetContainer();
        }

    }
}
