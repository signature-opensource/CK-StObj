using CK.Core;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace CK.StObj.Engine.Tests.Endpoint.Conformant
{
    sealed class FakeStObjMap : IStObjMap, IStObjObjectMap, IStObjServiceMap
    {
        public IStObjObjectMap StObjs => this;

        public SHA1Value GeneratedSignature => throw new NotImplementedException();

        public IStObjServiceMap Services => this;

        public IReadOnlyList<string> Names => throw new NotImplementedException();

        public IReadOnlyCollection<VFeature> Features => throw new NotImplementedException();

        public IReadOnlyDictionary<Type, IStObjMultipleInterface> MultipleMappings => ImmutableDictionary<Type,IStObjMultipleInterface>.Empty;

        IReadOnlyList<IStObjFinalImplementation> IStObjObjectMap.FinalImplementations => Array.Empty<IStObjFinalImplementation>();

        IEnumerable<StObjMapping> IStObjObjectMap.StObjs => throw new NotImplementedException();

        IReadOnlyDictionary<Type, IStObjFinalImplementation> IStObjServiceMap.ObjectMappings => throw new NotImplementedException();

        IReadOnlyList<IStObjFinalImplementation> IStObjServiceMap.ObjectMappingList => throw new NotImplementedException();

        IReadOnlyDictionary<Type, IStObjServiceClassDescriptor> IStObjServiceMap.Mappings => throw new NotImplementedException();

        IReadOnlyList<IStObjServiceClassDescriptor> IStObjServiceMap.MappingList => Array.Empty<IStObjServiceClassDescriptor>();

        public IStObjFinalClass? ToLeaf( Type t ) => null;

        // This method is generated by code.
        // Note: When no EndpointDefinition exist, the code that manages endpoints is not generated.
        public bool ConfigureServices( in StObjContextRoot.ServiceRegister reg )
        {
            // Gives the real objects an opportunity to configure the services.
            RealObjectConfigureServices( in reg );

            // - We build a mapping of ServiceType -> ServiceDescriptors from the global configuration (only if there are endpoints).
            var mappings = EndpointHelper.CreateInitialMapping( reg.Monitor, reg.Services, FakeEndpointTypeManager_CK._endpointServices.Contains );

            // - We add the code generated HostedServiceLifetimeTrigger to the global container: the endpoint
            //   containers don't need it.
            //   We don't do it here to avoid creating yet another fake implementation.
            //   
            // reg.Services.Add( new Microsoft.Extensions.DependencyInjection.ServiceDescriptor( typeof( IHostedService ), typeof( HostedServiceLifetimeTrigger ), ServiceLifetime.Singleton ) );
            //

            //  - Then an instance of the special "super singleton" EndpointTypeManager is created.
            //    It is the exact same instance that will be available from all the containers: the global and every endpoint containers, it is
            //    the global hook, the relay to the global service provider for the endpoint containers.
            var theEPTM = new FakeEndpointTypeManager_CK();
            var trueSingletons = theEPTM.CreateTrueSingletons( this );
            reg.Services.AddRange( trueSingletons );

            // ServiceDescriptors are created from the EngineStObjMap and added to the global configuration
            // and to the mappings.
            EndpointHelper.FillStObjMappingsWithEndpoints( reg.Monitor, this, reg.Services, mappings );

            // We can now close the global container. Waiting for .Net 8.
            // (reg.Services as Microsoft.Extensions.DependencyInjection.ServiceCollection)?.MakeReadOnly();
            bool success = true;
            //  - Then all the endpointType instances create their own ServiceCollection by processing the 
            //    descriptors from the mappings and adding their own EndpointScopeData<TScopeData> scoped data holder
            //    and the true instance singletons IStObjMap, EndpointTypeManager, the EndpointType and the IEnumerable<IEndpointType>. 
            foreach( var e in theEPTM._endpointTypes )
            {
                if( !e.ConfigureServices( reg.Monitor, this, mappings, trueSingletons ) ) success = false;
            }
            return success;
        }

        // This is a code generated method that calls all static RegisterStartupServices methods and then
        // all static ConfigureServices methods (following the topological dependency order).
        void RealObjectConfigureServices( in StObjContextRoot.ServiceRegister register )
        {
        }

        IStObjFinalImplementation? IStObjObjectMap.ToLeaf( Type t )
        {
            throw new NotImplementedException();
        }

        object? IStObjObjectMap.Obtain( Type t )
        {
            throw new NotImplementedException();
        }
    }
}
